<template>
    <div>
        <h4>Vulnerability Analysis</h4>
        <n-spin :show="loading">
            <n-space vertical>
                <n-data-table
                    :columns="columns"
                    :data="analysisRecords"
                    :pagination="{ pageSize: 20 }"
                    :row-key="(row: any) => row.uuid"
                />
            </n-space>
        </n-spin>
    </div>
    
    <create-vuln-analysis-modal
        v-model:show="showCreateAnalysisModal"
        :finding-row="selectedFindingRow"
        :org-uuid="myorg.uuid"
        :artifact-view-only="true"
        @created="onAnalysisCreated"
    />
    
    <update-vuln-analysis-modal
        v-model:show="showUpdateAnalysisModal"
        :analysis-record="selectedAnalysisRecord"
        @updated="onAnalysisUpdated"
    />
</template>

<script lang="ts">
export default {
    name: 'VulnerabilityAnalysis'
}
</script>

<script lang="ts" setup>
import { ref, computed, onMounted, h, ComputedRef } from 'vue'
import { NSpin, NDataTable, NTag, NSpace, NTooltip, NIcon, DataTableColumns } from 'naive-ui'
import { Info20Regular } from '@vicons/fluent'
import { ArrowRight, Edit } from '@vicons/tabler'
import gql from 'graphql-tag'
import graphqlClient from '@/utils/graphql'
import { useStore } from 'vuex'
import { useNotification, NotificationType } from 'naive-ui'
import CreateVulnAnalysisModal from './CreateVulnAnalysisModal.vue'
import UpdateVulnAnalysisModal from './UpdateVulnAnalysisModal.vue'

const store = useStore()
const notification = useNotification()
const loading = ref(false)
const analysisRecords = ref<any[]>([])
const showCreateAnalysisModal = ref(false)
const showUpdateAnalysisModal = ref(false)
const selectedFindingRow = ref<any>(null)
const selectedAnalysisRecord = ref<any>(null)

const myorg: ComputedRef<any> = computed((): any => store.getters.myorg)

const notify = async function (type: NotificationType, title: string, content: string) {
    notification[type]({
        content: content,
        meta: title,
        duration: 3500,
        keepAliveOnHover: true
    })
}

const columns: DataTableColumns<any> = [
    {
        title: 'Finding ID',
        key: 'findingId',
        width: 180,
        render: (row: any) => {
            const findingId = h('span', {}, row.findingId)
            
            if (row.findingAliases && row.findingAliases.length > 0) {
                const aliasesText = 'Aliases: ' + row.findingAliases.join(', ')
                const infoIcon = h(NTooltip, {
                    trigger: 'hover'
                }, {
                    trigger: () => h(NIcon, {
                        style: 'margin-left: 6px; cursor: pointer;',
                        size: 16
                    }, () => h(Info20Regular)),
                    default: () => aliasesText
                })
                
                return h('div', { style: 'display: flex; align-items: center;' }, [findingId, infoIcon])
            }
            
            return findingId
        }
    },
    {
        title: 'Finding Type',
        key: 'findingType',
        width: 140,
        render: (row: any) => {
            return h(NTag, { type: 'info', size: 'small' }, { default: () => row.findingType })
        }
    },
    {
        title: 'Severity',
        key: 'severity',
        width: 120,
        render: (row: any) => {
            if (!row.severity) {
                return '-'
            }
            const severityColors: any = {
                CRITICAL: 'error',
                HIGH: 'error',
                MEDIUM: 'warning',
                LOW: 'info',
                UNASSIGNED: 'default'
            }
            return h(NTag, { 
                type: severityColors[row.severity] || 'default', 
                size: 'small' 
            }, { default: () => row.severity })
        }
    },
    {
        title: 'Location',
        key: 'location',
        minWidth: 200,
        ellipsis: { tooltip: true }
    },
    {
        title: 'Location Type',
        key: 'locationType',
        width: 120,
        render: (row: any) => {
            return h(NTag, { type: 'success', size: 'small' }, { default: () => row.locationType })
        }
    },
    {
        title: 'Scope',
        key: 'scope',
        width: 150,
        render: (row: any) => {
            const tag = h(NTag, { type: 'info', size: 'small' }, { default: () => row.scope })
            
            if (row.scopeUuid) {
                // Build tooltip content with optional link for RELEASE scope
                const tooltipContent = () => {
                    if (row.scope === 'RELEASE') {
                        return h('div', { style: 'display: flex; align-items: center; gap: 8px;' }, [
                            h('span', {}, `Scope UUID: ${row.scopeUuid}`),
                            h('a', {
                                href: `/release/show/${row.scopeUuid}`,
                                target: '_blank',
                                style: 'display: inline-flex; align-items: center; color: #18a058; text-decoration: none;',
                                onClick: (e: Event) => {
                                    e.stopPropagation()
                                }
                            }, [
                                h(NIcon, { size: 16 }, () => h(ArrowRight))
                            ])
                        ])
                    }
                    return `Scope UUID: ${row.scopeUuid}`
                }
                
                const infoIcon = h(NTooltip, {
                    trigger: 'hover'
                }, {
                    trigger: () => h(NIcon, {
                        style: 'margin-left: 6px; cursor: pointer;',
                        size: 16
                    }, () => h(Info20Regular)),
                    default: tooltipContent
                })
                
                return h('div', { style: 'display: flex; align-items: center;' }, [tag, infoIcon])
            }
            
            return tag
        }
    },
    {
        title: 'Current State',
        key: 'analysisState',
        width: 150,
        render: (row: any) => {
            const stateColors: any = {
                EXPLOITABLE: 'error',
                IN_TRIAGE: 'warning',
                FALSE_POSITIVE: 'success',
                NOT_AFFECTED: 'info'
            }
            
            const tag = h(NTag, { 
                type: stateColors[row.analysisState] || 'default', 
                size: 'small' 
            }, { default: () => row.analysisState })
            
            if (row.analysisJustification) {
                const infoIcon = h(NTooltip, {
                    trigger: 'hover'
                }, {
                    trigger: () => h(NIcon, {
                        style: 'margin-left: 6px; cursor: pointer;',
                        size: 16
                    }, () => h(Info20Regular)),
                    default: () => "Justification: " + row.analysisJustification
                })
                
                return h('div', { style: 'display: flex; align-items: center;' }, [tag, infoIcon])
            }
            
            return tag
        }
    },
    {
        title: 'History',
        key: 'analysisHistory',
        minWidth: 250,
        render: (row: any) => {
            if (!row.analysisHistory || row.analysisHistory.length === 0) {
                return '-'
            }
            
            return h(NSpace, { vertical: true, size: 'small' }, {
                default: () => row.analysisHistory.map((history: any, index: number) => {
                    const stateColors: any = {
                        EXPLOITABLE: 'error',
                        IN_TRIAGE: 'warning',
                        FALSE_POSITIVE: 'success',
                        NOT_AFFECTED: 'info'
                    }
                    
                    const dateStr = history.createdDate 
                        ? new Date(history.createdDate).toLocaleString('en-CA', { hour12: false })
                        : 'Unknown'
                    
                    // Build tooltip content
                    const tooltipLines: string[] = []
                    if (history.justification) {
                        tooltipLines.push(`Justification: ${history.justification}`)
                    }
                    if (history.severity) {
                        tooltipLines.push(`Severity: ${history.severity}`)
                    }
                    if (history.details) {
                        tooltipLines.push(`Details: ${history.details}`)
                    }
                    const tooltipContent = tooltipLines.length > 0 ? tooltipLines.join('\n') : 'No additional information'
                    
                    const tag = h(NTag, { 
                        type: stateColors[history.state] || 'default', 
                        size: 'tiny',
                        style: 'margin-right: 4px;'
                    }, { default: () => history.state })
                    
                    const dateSpan = h('span', { style: 'font-size: 12px;' }, dateStr)
                    
                    const infoIcon = h(NTooltip, {
                        trigger: 'hover'
                    }, {
                        trigger: () => h(NIcon, {
                            style: 'margin-left: 6px; cursor: pointer;',
                            size: 14
                        }, () => h(Info20Regular)),
                        default: () => tooltipContent
                    })
                    
                    return h('div', { 
                        key: index, 
                        style: 'display: flex; align-items: center; font-size: 12px;' 
                    }, [tag, dateSpan, infoIcon])
                })
            })
        }
    },
    {
        title: 'Actions',
        key: 'actions',
        width: 80,
        render: (row: any) => {
            const editIcon = h(NIcon, {
                title: 'Edit Analysis',
                class: 'icons clickable',
                size: 25,
                onClick: () => handleEdit(row)
            }, () => h(Edit))
            
            return h('div', {}, [editIcon])
        }
    }
]

const handleEdit = (row: any) => {
    // Check if this is a constructed record from findingsPerDay (starts with 'new-')
    if (row.uuid.startsWith('new-')) {
        // This is a constructed record - open create modal with ORG-only scope
        // Map findingAliases array to the format expected by CreateVulnAnalysisModal
        const aliases = (row.findingAliases || []).map((alias: string) => ({ aliasId: alias }))
        
        selectedFindingRow.value = {
            id: row.findingId,
            type: row.findingType,
            purl: row.location,
            location: row.location,
            aliases: aliases,
            severity: row.severity
        }
        showCreateAnalysisModal.value = true
    } else {
        // This is a real record - open update modal
        selectedAnalysisRecord.value = row
        showUpdateAnalysisModal.value = true
    }
}

const onAnalysisCreated = async () => {
    // Refresh the analysis records after creating
    await fetchAnalysisRecords()
}

const onAnalysisUpdated = async () => {
    // Refresh the analysis records after updating
    await fetchAnalysisRecords()
}

const fetchAnalysisRecords = async () => {
    if (!myorg.value || !myorg.value.uuid) {
        notify('error', 'Error', 'No organization selected')
        return
    }
    
    loading.value = true
    try {
        // Get today's date in UTC format YYYY-MM-DD
        const today = new Date()
        const dateStr = today.toISOString().split('T')[0]
        
        // Fetch both analysis records and today's findings in parallel
        const [analysisResponse, findingsResponse] = await Promise.all([
            graphqlClient.query({
                query: gql`
                    query getVulnAnalysis($org: ID!) {
                        getVulnAnalysis(org: $org) {
                            uuid
                            org
                            location
                            locationType
                            findingId
                            findingAliases
                            findingType
                            scope
                            scopeUuid
                            analysisState
                            analysisJustification
                            severity
                            analysisHistory {
                                state
                                justification
                                severity
                                details
                                createdDate
                            }
                        }
                    }
                `,
                variables: {
                    org: myorg.value.uuid
                },
                fetchPolicy: 'no-cache'
            }),
            graphqlClient.query({
                query: gql`
                    query findingsPerDay($orgUuid: ID!, $date: String!) {
                        findingsPerDay(orgUuid: $orgUuid, date: $date) {
                            vulnerabilityDetails {
                                purl
                                vulnId
                                severity
                                analysisState
                                aliases {
                                    type
                                    aliasId
                                }
                                sources {
                                    artifact
                                    release
                                    variant
                                }
                            }
                            violationDetails {
                                purl
                                type
                                license
                                violationDetails
                                analysisState
                                sources {
                                    artifact
                                    release
                                    variant
                                }
                            }
                        }
                    }
                `,
                variables: {
                    orgUuid: myorg.value.uuid,
                    date: dateStr
                },
                fetchPolicy: 'no-cache'
            })
        ])
        
        const existingAnalysis = analysisResponse.data.getVulnAnalysis || []
        
        // Build a set of all analyzed finding IDs and their aliases
        const analyzedIds = new Set<string>()
        existingAnalysis.forEach((record: any) => {
            analyzedIds.add(record.findingId)
            if (record.findingAliases && Array.isArray(record.findingAliases)) {
                record.findingAliases.forEach((alias: string) => analyzedIds.add(alias))
            }
        })
        
        // Process findings from findingsPerDay
        const newFindings: any[] = []
        const metrics = findingsResponse.data.findingsPerDay
        
        if (metrics) {
            // Process vulnerabilities
            if (metrics.vulnerabilityDetails && Array.isArray(metrics.vulnerabilityDetails)) {
                metrics.vulnerabilityDetails.forEach((vuln: any) => {
                    // Check if this vulnerability is already analyzed
                    const vulnAliases = vuln.aliases?.map((a: any) => a.aliasId) || []
                    const allIds = [vuln.vulnId, ...vulnAliases]
                    const isAnalyzed = allIds.some((id: string) => analyzedIds.has(id))
                    
                    if (!isAnalyzed) {
                        // Transform to analysis record format
                        newFindings.push({
                            uuid: `new-vuln-${vuln.vulnId}-${vuln.purl}`,
                            org: myorg.value.uuid,
                            location: vuln.purl,
                            locationType: 'PURL',
                            findingId: vuln.vulnId,
                            findingAliases: vulnAliases,
                            findingType: 'VULNERABILITY',
                            scope: 'ORG',
                            scopeUuid: myorg.value.uuid,
                            analysisState: 'IN_TRIAGE',
                            analysisJustification: null,
                            severity: vuln.severity || null,
                            analysisHistory: []
                        })
                    }
                })
            }
            
            // Process violations
            if (metrics.violationDetails && Array.isArray(metrics.violationDetails)) {
                metrics.violationDetails.forEach((violation: any) => {
                    // Create a unique ID for violations (they don't have vulnId)
                    const violationId = `${violation.type}-${violation.license || violation.violationDetails}`
                    
                    if (!analyzedIds.has(violationId)) {
                        newFindings.push({
                            uuid: `new-violation-${violationId}-${violation.purl}`,
                            org: myorg.value.uuid,
                            location: violation.purl,
                            locationType: 'PURL',
                            findingId: violationId,
                            findingAliases: [],
                            findingType: 'VIOLATION',
                            scope: 'ORG',
                            scopeUuid: myorg.value.uuid,
                            analysisState: 'IN_TRIAGE',
                            analysisJustification: null,
                            severity: null,
                            analysisHistory: []
                        })
                    }
                })
            }
        }
        
        // Combine existing analysis and new findings
        analysisRecords.value = [...existingAnalysis, ...newFindings]
    } catch (error: any) {
        console.error('Error fetching vulnerability analysis records:', error)
        notify('error', 'Error', 'Failed to fetch vulnerability analysis records')
        analysisRecords.value = []
    } finally {
        loading.value = false
    }
}

onMounted(() => {
    fetchAnalysisRecords()
})
</script>

<style scoped>
h4 {
    margin-bottom: 20px;
}
</style>
