<template>
    <div>
        <create-vuln-analysis-modal
            v-model:show="showCreateAnalysisModal"
            :finding-row="selectedFindingRow"
            :org-uuid="myorg.uuid"
            :component-uuid="selectedComponentProduct"
            :component-name="selectedComponentDetails?.name"
            :component-type="selectedComponentDetails?.type"
            :branch-uuid="selectedBranchFeatureSet"
            :branch-name="selectedBranchDetails?.name"
            :release-uuid="selectedRelease"
            :release-version="selectedReleaseDetails?.version"
            :feature-set-label="featureSetLabel"
            :available-scopes-only="availableScopesForCreation"
            @created="onAnalysisCreated"
        />
        
        <update-vuln-analysis-modal
            v-model:show="showUpdateAnalysisModal"
            :analysis-record="selectedAnalysisRecord"
            @updated="onAnalysisUpdated"
        />
        
        <releases-by-cve
            v-model:show="showViewReleasesModal"
            :cve-id="selectedCveId"
            :org-uuid="myorg.uuid"
            :perspective-uuid="currentPerspectiveUuid"
            :perspective-name="currentPerspectiveName"
            :show-is-latest-column="true"
        />
        <div id="vulnAnalysisMain">
            <h4>Finding Analysis</h4>
            <n-spin :show="loading">
                <n-space vertical>
                    <n-space align="center" style="margin-bottom: 16px;">
                        <span style="font-weight: 500; margin-right: 8px;">Filters:</span>
                        <n-space vertical :size="4">
                            <span style="font-size: 12px; color: #666;">Type</span>
                            <n-select
                                v-model:value="selectedType"
                                :options="typeOptions"
                                placeholder="Any"
                                style="width: 350px;"
                            />
                        </n-space>
                        <n-space vertical :size="4">
                            <span style="font-size: 12px; color: #666;">Component / Product</span>
                            <n-select
                                v-if="componentProductOptionsLoaded"
                                v-model:value="selectedComponentProduct"
                                :options="componentProductOptions"
                                placeholder="Any"
                                style="width: 350px;"
                                filterable
                                clearable
                            />
                            <n-skeleton v-else height="34px" width="350px" />
                        </n-space>
                        <n-space vertical :size="4">
                            <span style="font-size: 12px; color: #666;">Branch / {{ featureSetLabel }}</span>
                            <n-select
                                v-if="branchFeatureSetOptionsLoaded"
                                v-model:value="selectedBranchFeatureSet"
                                :options="branchFeatureSetOptions"
                                placeholder="Any"
                                style="width: 350px;"
                                filterable
                                clearable
                            />
                            <n-skeleton v-else height="34px" width="350px" />
                        </n-space>
                        <n-space vertical :size="4">
                            <span style="font-size: 12px; color: #666;">Release</span>
                            <n-select
                                v-if="releaseOptionsLoaded"
                                v-model:value="selectedRelease"
                                :options="releaseOptions"
                                placeholder="Any"
                                style="width: 350px;"
                                filterable
                                clearable
                            />
                            <n-skeleton v-else height="34px" width="350px" />
                        </n-space>
                    </n-space>
                    <n-input
                        v-model:value="findingIdSearch"
                        placeholder="Search Finding ID..."
                        clearable
                        style="max-width: 300px; margin-bottom: 12px;"
                    />
                    <n-data-table
                        :columns="columns"
                        :data="filteredRecords"
                        :pagination="{ pageSize: 20 }"
                        :row-key="(row: any) => row.uuid"
                    />
                </n-space>
            </n-spin>
        </div>
    </div>
</template>

<script lang="ts">
export default {
    name: 'VulnerabilityAnalysis'
}
</script>

<script lang="ts" setup>
import { ref, computed, onMounted, watch, h, ComputedRef, Ref } from 'vue'
import { NSpin, NDataTable, NTag, NSpace, NTooltip, NIcon, NInput, NSelect, NSkeleton, DataTableColumns } from 'naive-ui'
import { useRoute, useRouter } from 'vue-router'
import { Info20Regular } from '@vicons/fluent'
import { ArrowRight, Edit, Eye, Plus } from '@vicons/tabler'
import gql from 'graphql-tag'
import graphqlClient from '@/utils/graphql'
import { useStore } from 'vuex'
import { useNotification, NotificationType } from 'naive-ui'
import CreateVulnAnalysisModal from './CreateVulnAnalysisModal.vue'
import UpdateVulnAnalysisModal from './UpdateVulnAnalysisModal.vue'
import ReleasesByCve from './ReleasesByCve.vue'
import Swal from 'sweetalert2'
import commonFunctions from '@/utils/commonFunctions'
import { ReleaseVulnerabilityService } from '@/utils/releaseVulnerabilityService'

// GraphQL fragment for findings details (DRY)
const FINDINGS_DETAILS_FRAGMENT = `
    vulnerabilityDetails {
        purl
        vulnId
        severity
        analysisState
        aliases {
            type
            aliasId
        }
        sources {
            artifact
            release
            variant
        }
    }
    violationDetails {
        purl
        type
        license
        violationDetails
        analysisState
        sources {
            artifact
            release
            variant
        }
    }
    weaknessDetails {
        cweId
        ruleId
        location
        fingerprint
        severity
        analysisState
        sources {
            artifact
            release
            variant
        }
    }
`

// GraphQL fragment for vuln analysis fields (DRY)
const VULN_ANALYSIS_FIELDS_FRAGMENT = `
    uuid
    org
    location
    locationType
    findingId
    findingAliases
    findingType
    scope
    scopeUuid
    analysisState
    analysisJustification
    severity
    analysisHistory {
        state
        justification
        severity
        details
        createdDate
    }
    releaseDetails {
        uuid
        version
    }
    branchDetails {
        uuid
        name
    }
    componentDetails {
        uuid
        name
        type
    }
`

const store = useStore()
const route = useRoute()
const router = useRouter()
const notification = useNotification()
const loading = ref(false)
const analysisRecords = ref<any[]>([])
const findingIdSearch = ref('')
const showCreateAnalysisModal = ref(false)
const showUpdateAnalysisModal = ref(false)
const showViewReleasesModal = ref(false)
const selectedFindingRow = ref<any>(null)
const selectedAnalysisRecord = ref<any>(null)
const selectedCveId = ref('')
const availableScopesForCreation = ref<string[]>([])

// Filter selectors state - initialize from URL query parameters
const selectedType: Ref<string> = ref((route.query.type as string) || 'COMPONENT')
const selectedComponentProduct: Ref<string> = ref((route.query.componentProduct as string) || '')
const selectedBranchFeatureSet: Ref<string> = ref((route.query.branchFeatureSet as string) || '')
const selectedRelease: Ref<string> = ref((route.query.release as string) || '')

// Data for selectors
const componentsProducts = ref<any[]>([])
const branches = ref<any[]>([])
const releases = ref<any[]>([])

const myorg: ComputedRef<any> = computed((): any => store.getters.myorg)
const myuser: ComputedRef<any> = computed((): any => store.getters.myuser)
const featureSetLabel = computed(() => myorg.value?.terminology?.featureSetLabel || 'Feature Set')
const myperspective: ComputedRef<string> = computed((): string => store.getters.myperspective)
const perspectives: ComputedRef<any[]> = computed((): any => store.getters.perspectivesOfOrg(myorg.value?.uuid || ''))

// Get current perspective name and UUID for modal
const currentPerspectiveUuid = computed(() => {
    return myperspective.value !== 'default' ? myperspective.value : undefined
})

const currentPerspectiveName = computed(() => {
    if (myperspective.value === 'default') {
        return undefined
    }
    const perspective = perspectives.value.find((p: any) => p.uuid === myperspective.value)
    return perspective ? perspective.name : undefined
})

// Selected component/branch/release details for CreateVulnAnalysisModal
const selectedComponentDetails = computed(() => {
    if (!selectedComponentProduct.value) return null
    return componentsProducts.value.find((item: any) => item.uuid === selectedComponentProduct.value)
})
const selectedBranchDetails = computed(() => {
    if (!selectedBranchFeatureSet.value) return null
    return branches.value.find((item: any) => item.uuid === selectedBranchFeatureSet.value)
})
const selectedReleaseDetails = computed(() => {
    if (!selectedRelease.value) return null
    return releases.value.find((item: any) => item.uuid === selectedRelease.value)
})

// Type selector options - Component is default
const typeOptions = [
    { label: 'Component', value: 'COMPONENT' },
    { label: 'Product', value: 'PRODUCT' }
]

// Component/Product selector options
const componentProductOptions: ComputedRef<any[]> = computed(() => {
    const options = [{ label: 'Any', value: '' }]
    const filtered = componentsProducts.value.filter((item: any) => {
        if (selectedType.value === 'ANY') return true
        return item.type === selectedType.value
    })
    filtered.forEach((item: any) => {
        options.push({ label: item.name, value: item.uuid })
    })
    return options
})

// Branch/Feature Set selector options
const branchFeatureSetOptions: ComputedRef<any[]> = computed(() => {
    const options = [{ label: 'Any', value: '' }]
    branches.value.forEach((branch: any) => {
        options.push({ label: branch.name, value: branch.uuid })
    })
    return options
})

// Release selector options
const releaseOptions: ComputedRef<any[]> = computed(() => {
    const options = [{ label: 'Any', value: '' }]
    releases.value.forEach((release: any) => {
        options.push({ label: release.version, value: release.uuid })
    })
    return options
})

// Computed properties to check if options are loaded
const componentProductOptionsLoaded = computed(() => componentsProducts.value.length > 0)
const branchFeatureSetOptionsLoaded = computed(() => {
    // If no component selected, consider it loaded (shows "Any" option)
    if (!selectedComponentProduct.value) return true
    // Otherwise, check if branches are loaded
    return branches.value.length > 0
})
const releaseOptionsLoaded = computed(() => {
    // If no branch selected, consider it loaded (shows "Any" option)
    if (!selectedBranchFeatureSet.value) return true
    // Otherwise, check if releases are loaded
    return releases.value.length > 0
})

const isWritable: ComputedRef<boolean> = computed((): boolean => {
    if (!myorg.value || !myorg.value.uuid || !myuser.value) {
        return false
    }
    return commonFunctions.isWritable(myorg.value.uuid, myuser.value, 'ORGANIZATION')
})

const notify = async function (type: NotificationType, title: string, content: string) {
    notification[type]({
        content: content,
        meta: title,
        duration: 3500,
        keepAliveOnHover: true
    })
}

// Helper function to create vulnerability links with confirmation dialog
function createVulnerabilityLink(id: string) {
    const confirmAndOpen = async (e: Event, href: string) => {
        e.preventDefault()
        try {
            const LS_KEY = 'rearm_external_link_consent_until'
            const now = Date.now()
            const stored = localStorage.getItem(LS_KEY)
            if (stored && Number(stored) > now) {
                window.open(href, '_blank')
                return
            }

            const result = await Swal.fire({
                icon: 'info',
                title: 'Open external link?\n',
                text: 'This will open a vulnerability database resource external to ReARM. Please confirm that you want to proceed.',
                showCancelButton: true,
                confirmButtonText: 'Open',
                cancelButtonText: 'Cancel',
                input: 'checkbox',
                inputValue: 0,
                inputPlaceholder: "Don't ask me again for 15 days"
            })
            if (result.isConfirmed) {
                if (result.value === 1) {
                    const fifteenDaysMs = 15 * 24 * 60 * 60 * 1000
                    localStorage.setItem(LS_KEY, String(now + fifteenDaysMs))
                }
                window.open(href, '_blank')
            }
        } catch (err) {
            // Fail open on errors to avoid blocking navigation unexpectedly
            window.open(href, '_blank')
        }
    }
    
    if (id.startsWith('ALPINE-CVE-') || id.startsWith('CVE-') || id.startsWith('GHSA-')) {
        const href = `https://osv.dev/vulnerability/${id}`
        return h('a', {
            href,
            target: '_blank',
            rel: 'noopener noreferrer',
            onClick: (e: Event) => confirmAndOpen(e, href)
        }, id)
    }
    if (id.startsWith('CWE-')) {
        const raw = id.slice(4)
        const num = String(parseInt(raw, 10))
        if (num && num !== 'NaN') {
            const href = `https://cwe.mitre.org/data/definitions/${num}.html`
            return h('a', {
                href,
                target: '_blank',
                rel: 'noopener noreferrer',
                onClick: (e: Event) => confirmAndOpen(e, href)
            }, id)
        }
    }
    return id
}

const filteredRecords = computed(() => {
    if (!findingIdSearch.value) {
        return analysisRecords.value
    }
    const searchValue = findingIdSearch.value.toLowerCase()
    return analysisRecords.value.filter(record => {
        // Search in finding ID
        if (record.findingId.toLowerCase().includes(searchValue)) {
            return true
        }
        // Search in aliases
        if (record.findingAliases && record.findingAliases.length > 0) {
            return record.findingAliases.some((alias: string) => 
                alias.toLowerCase().includes(searchValue)
            )
        }
        return false
    })
})

const handleViewReleases = (row: any) => {
    selectedCveId.value = row.findingId
    showViewReleasesModal.value = true
    
    // Update URL with cveId query parameter without refreshing
    const newQuery = new URLSearchParams(window.location.search)
    newQuery.set('cveId', row.findingId)
    const newUrl = `${window.location.pathname}?${newQuery.toString()}`
    window.history.replaceState({}, '', newUrl)
}

// Helper function to check if a specific scope with UUID exists for a finding
const hasScopeWithUuid = (findingId: string, location: string, scope: string, scopeUuid: string): boolean => {
    return analysisRecords.value.some(record => 
        record.findingId === findingId &&
        record.location === location &&
        record.scope === scope && 
        record.scopeUuid === scopeUuid &&
        !record.uuid.startsWith('new-')
    )
}

// Compute available scopes for a finding based on current filters
const getAvailableScopes = (row: any): string[] => {
    const scopes: string[] = []
    
    // Check if ORG scope with current org UUID exists
    if (!hasScopeWithUuid(row.findingId, row.location, 'ORG', myorg.value.uuid)) {
        scopes.push('ORG')
    }
    
    // Check if COMPONENT scope with current component UUID exists
    if (selectedComponentProduct.value && !hasScopeWithUuid(row.findingId, row.location, 'COMPONENT', selectedComponentProduct.value)) {
        scopes.push('COMPONENT')
    }
    
    // Check if BRANCH scope with current branch UUID exists
    if (selectedBranchFeatureSet.value && !hasScopeWithUuid(row.findingId, row.location, 'BRANCH', selectedBranchFeatureSet.value)) {
        scopes.push('BRANCH')
    }
    
    // Check if RELEASE scope with current release UUID exists
    if (selectedRelease.value && !hasScopeWithUuid(row.findingId, row.location, 'RELEASE', selectedRelease.value)) {
        scopes.push('RELEASE')
    }
    
    // Sort scopes in hierarchy order: ORG -> COMPONENT -> BRANCH -> RELEASE
    const scopeOrder = { 'ORG': 0, 'COMPONENT': 1, 'BRANCH': 2, 'RELEASE': 3 }
    return scopes.sort((a, b) => scopeOrder[a as keyof typeof scopeOrder] - scopeOrder[b as keyof typeof scopeOrder])
}

const handleEdit = (row: any) => {
    // Check if this is a constructed record from findingsPerDay (starts with 'new-')
    if (row.uuid.startsWith('new-')) {
        // This is a constructed record - open create modal with ORG-only scope
        // Map findingAliases array to the format expected by CreateVulnAnalysisModal
        const aliases = (row.findingAliases || []).map((alias: string) => ({ aliasId: alias }))
        
        selectedFindingRow.value = {
            id: row.findingId,
            type: row.findingType,
            purl: row.location,
            location: row.location,
            aliases: aliases,
            severity: row.severity
        }
        
        // For new findings, don't restrict scopes (let modal compute based on filters)
        availableScopesForCreation.value = []
        showCreateAnalysisModal.value = true
    } else {
        // This is a real record - open update modal
        selectedAnalysisRecord.value = row
        showUpdateAnalysisModal.value = true
    }
}

const handleAddScope = (row: any) => {
    // Open create modal with available scopes for this finding
    const aliases = (row.findingAliases || []).map((alias: string) => ({ aliasId: alias }))
    
    selectedFindingRow.value = {
        id: row.findingId,
        type: row.findingType,
        purl: row.location,
        location: row.location,
        aliases: aliases,
        severity: row.severity
    }
    
    // Compute and pass only the available scopes for this specific finding
    availableScopesForCreation.value = getAvailableScopes(row)
    showCreateAnalysisModal.value = true
}

const columns: DataTableColumns<any> = [
    {
        title: 'Finding ID',
        key: 'findingId',
        width: 180,
        render: (row: any) => {
            const findingId = createVulnerabilityLink(row.findingId)
            
            if (row.findingAliases && row.findingAliases.length > 0) {
                const aliasesText = 'Aliases: ' + row.findingAliases.join(', ')
                const infoIcon = h(NTooltip, {
                    trigger: 'hover'
                }, {
                    trigger: () => h(NIcon, {
                        style: 'margin-left: 6px; cursor: pointer;',
                        size: 16
                    }, () => h(Info20Regular)),
                    default: () => aliasesText
                })
                
                return h('div', { style: 'display: flex; align-items: center;' }, [findingId, infoIcon])
            }
            
            return findingId
        }
    },
    {
        title: 'Finding Type',
        key: 'findingType',
        width: 140,
        filterOptions: [
            { label: 'Vulnerability', value: 'VULNERABILITY' },
            { label: 'Violation', value: 'VIOLATION' },
            { label: 'Weakness', value: 'WEAKNESS' }
        ],
        filter: (value: any, row: any) => row.findingType === value,
        render: (row: any) => {
            return h(NTag, { type: 'info', size: 'small' }, { default: () => row.findingType })
        }
    },
    {
        title: 'Severity',
        key: 'severity',
        width: 120,
        filterOptions: [
            { label: 'Critical', value: 'CRITICAL' },
            { label: 'High', value: 'HIGH' },
            { label: 'Medium', value: 'MEDIUM' },
            { label: 'Low', value: 'LOW' },
            { label: 'Unassigned', value: 'UNASSIGNED' }
        ],
        filter: (value: any, row: any) => row.severity === value,
        render: (row: any) => {
            if (!row.severity) {
                return '-'
            }
            const severityColors: any = {
                CRITICAL: 'error',
                HIGH: 'error',
                MEDIUM: 'warning',
                LOW: 'info',
                UNASSIGNED: 'default'
            }
            return h(NTag, { 
                type: severityColors[row.severity] || 'default', 
                size: 'small' 
            }, { default: () => row.severity })
        }
    },
    {
        title: 'PURL or Location',
        key: 'location',
        minWidth: 200,
        ellipsis: { tooltip: true }
    },
    {
        title: 'Scope',
        key: 'scope',
        width: 120,
        filterOptions: [
            { label: 'Org', value: 'ORG' },
            { label: 'Component', value: 'COMPONENT' },
            { label: 'Branch', value: 'BRANCH' },
            { label: 'Release', value: 'RELEASE' }
        ],
        filter: (value: any, row: any) => row.scope === value,
        render: (row: any) => {
            // Determine scope label based on component type
            let scopeLabel = row.scope
            if (row.componentDetails?.type === 'PRODUCT') {
                if (row.scope === 'COMPONENT') {
                    scopeLabel = 'PRODUCT'
                } else if (row.scope === 'BRANCH') {
                    scopeLabel = featureSetLabel.value.toUpperCase()
                }
            }
            return h(NTag, { type: 'info', size: 'small' }, { default: () => scopeLabel })
        }
    },
    {
        title: 'Scope Details',
        key: 'scopeDetails',
        minWidth: 200,
        render: (row: any) => {
            // Determine display based on scope type
            if (row.scope === 'ORG') {
                return h('span', { style: 'color: #666;' }, 'Organization-wide')
            }
            
            if (row.scope === 'COMPONENT' && row.componentDetails) {
                const routeName = row.componentDetails.type === 'PRODUCT' ? 'ProductsOfOrg' : 'ComponentsOfOrg'
                return h('a', {
                    style: 'color: #18a058; text-decoration: none; cursor: pointer;',
                    onClick: (e: Event) => {
                        e.stopPropagation()
                        router.push({
                            name: routeName,
                            params: {
                                orguuid: myorg.value.uuid,
                                compuuid: row.componentDetails.uuid
                            }
                        })
                    }
                }, row.componentDetails.name)
            }
            
            if (row.scope === 'BRANCH' && row.branchDetails) {
                const componentName = row.componentDetails?.name || ''
                const branchName = row.branchDetails.name
                const displayText = componentName ? `${componentName} - ${branchName}` : branchName
                
                if (row.componentDetails) {
                    const routeName = row.componentDetails.type === 'PRODUCT' ? 'ProductsOfOrg' : 'ComponentsOfOrg'
                    return h('a', {
                        style: 'color: #18a058; text-decoration: none; cursor: pointer;',
                        onClick: (e: Event) => {
                            e.stopPropagation()
                            router.push({
                                name: routeName,
                                params: {
                                    orguuid: myorg.value.uuid,
                                    compuuid: row.componentDetails.uuid,
                                    branchuuid: row.branchDetails.uuid
                                }
                            })
                        }
                    }, displayText)
                }
                return displayText
            }
            
            if (row.scope === 'RELEASE' && row.releaseDetails) {
                const componentName = row.componentDetails?.name || ''
                const releaseVersion = row.releaseDetails.version
                const displayText = componentName ? `${componentName} - ${releaseVersion}` : releaseVersion
                
                return h('a', {
                    style: 'color: #18a058; text-decoration: none; cursor: pointer;',
                    onClick: (e: Event) => {
                        e.stopPropagation()
                        router.push({
                            name: 'ReleaseView',
                            params: {
                                uuid: row.releaseDetails.uuid
                            }
                        })
                    }
                }, displayText)
            }
            
            // Fallback to scopeUuid if no details available
            return row.scopeUuid || '-'
        }
    },
    {
        title: 'Current State',
        key: 'analysisState',
        width: 180,
        filterOptions: [
            { label: 'Exploitable', value: 'EXPLOITABLE' },
            { label: 'In Triage', value: 'IN_TRIAGE' },
            { label: 'False Positive', value: 'FALSE_POSITIVE' },
            { label: 'Not Affected', value: 'NOT_AFFECTED' }
        ],
        filter: (value: any, row: any) => row.analysisState === value,
        render: (row: any) => {
            const stateColors: any = {
                EXPLOITABLE: 'error',
                IN_TRIAGE: 'warning',
                FALSE_POSITIVE: 'success',
                NOT_AFFECTED: 'info'
            }
            
            const tag = h(NTag, { 
                type: stateColors[row.analysisState] || 'default', 
                size: 'small' 
            }, { default: () => row.analysisState })
            
            if (row.analysisJustification) {
                const infoIcon = h(NTooltip, {
                    trigger: 'hover'
                }, {
                    trigger: () => h(NIcon, {
                        style: 'margin-left: 6px; cursor: pointer;',
                        size: 16
                    }, () => h(Info20Regular)),
                    default: () => "Justification: " + row.analysisJustification
                })
                
                return h('div', { style: 'display: flex; align-items: center;' }, [tag, infoIcon])
            }
            
            return tag
        }
    },
    {
        title: 'History',
        key: 'analysisHistory',
        minWidth: 250,
        render: (row: any) => {
            if (!row.analysisHistory || row.analysisHistory.length === 0) {
                return '-'
            }
            
            return h(NSpace, { vertical: true, size: 'small' }, {
                default: () => [...row.analysisHistory].reverse().map((history: any, index: number) => {
                    const stateColors: any = {
                        EXPLOITABLE: 'error',
                        IN_TRIAGE: 'warning',
                        FALSE_POSITIVE: 'success',
                        NOT_AFFECTED: 'info'
                    }
                    
                    const dateStr = history.createdDate 
                        ? new Date(history.createdDate).toLocaleString('en-CA', { hour12: false })
                        : 'Unknown'
                    
                    // Build tooltip content
                    const tooltipLines: string[] = []
                    if (history.justification) {
                        tooltipLines.push(`Justification: ${history.justification}`)
                    }
                    if (history.severity) {
                        tooltipLines.push(`Severity: ${history.severity}`)
                    }
                    if (history.details) {
                        tooltipLines.push(`Details: ${history.details}`)
                    }
                    const tooltipContent = tooltipLines.length > 0 ? tooltipLines.join('\n') : 'No additional information'
                    
                    const tag = h(NTag, { 
                        type: stateColors[history.state] || 'default', 
                        size: 'tiny',
                        style: 'margin-right: 4px;'
                    }, { default: () => history.state })
                    
                    const dateSpan = h('span', { style: 'font-size: 12px;' }, dateStr)
                    
                    const infoIcon = h(NTooltip, {
                        trigger: 'hover'
                    }, {
                        trigger: () => h(NIcon, {
                            style: 'margin-left: 6px; cursor: pointer;',
                            size: 14
                        }, () => h(Info20Regular)),
                        default: () => tooltipContent
                    })
                    
                    return h('div', { 
                        key: index, 
                        style: 'display: flex; align-items: center; font-size: 12px;' 
                    }, [tag, dateSpan, infoIcon])
                })
            })
        }
    },
    {
        title: 'Actions',
        key: 'actions',
        width: 120,
        render: (row: any) => {
            const icons: any[] = []
            
            if (row.findingType === 'VULNERABILITY') {
                const eyeIcon = h(NIcon, {
                    title: 'View Affected Releases',
                    class: 'icons clickable',
                    size: 24,
                    style: 'margin-right: 2px;',
                    onClick: () => handleViewReleases(row)
                }, () => h(Eye))
                icons.push(eyeIcon)
            }
            
            if (isWritable.value) {
                const editIcon = h(NIcon, {
                    title: 'Edit Analysis',
                    class: 'icons clickable',
                    size: 24,
                    style: 'margin-right: 2px;',
                    onClick: () => handleEdit(row)
                }, () => h(Edit))
                icons.push(editIcon)
                
                // Show Add Scope button for existing findings with available scopes
                if (!row.uuid.startsWith('new-')) {
                    const availableScopes = getAvailableScopes(row)
                    if (availableScopes.length > 0) {
                        const addScopeIcon = h(NIcon, {
                            title: 'Add Scope',
                            class: 'icons clickable',
                            size: 24,
                            onClick: () => handleAddScope(row)
                        }, () => h(Plus))
                        icons.push(addScopeIcon)
                    }
                }
            }
            
            return h('div', { style: 'display: flex; align-items: center;' }, icons)
        }
    }
]

const onAnalysisCreated = async () => {
    // Refresh the analysis records after creating
    await fetchAnalysisRecords()
}

const onAnalysisUpdated = async () => {
    // Refresh the analysis records after updating
    await fetchAnalysisRecords()
}

// Watch for modal close to remove cveId from URL
watch(showViewReleasesModal, (newValue) => {
    if (!newValue) {
        // Remove cveId from query params when modal closes without refreshing
        const newQuery = new URLSearchParams(window.location.search)
        if (newQuery.has('cveId')) {
            newQuery.delete('cveId')
            const newUrl = newQuery.toString() ? `${window.location.pathname}?${newQuery.toString()}` : window.location.pathname
            window.history.replaceState({}, '', newUrl)
        }
    }
})

const fetchAnalysisRecords = async () => {
    if (!myorg.value || !myorg.value.uuid) {
        notify('error', 'Error', 'No organization selected')
        return
    }
    
    loading.value = true
    try {
        // Get today's date in UTC format YYYY-MM-DD
        const today = new Date()
        const dateStr = today.toISOString().split('T')[0]
        
        // Determine which queries to use based on selections
        // Priority: Release > Branch > Component > Perspective > Org
        let analysisQuery: any
        let analysisVariables: any
        let analysisResponseKey: string
        let findingsQuery: any
        let findingsVariables: any
        let findingsResponseKey: string
        let useReleaseMetrics = false
        
        if (selectedRelease.value) {
            // Use release-specific query for analysis
            analysisQuery = gql`
                query getVulnAnalysisByRelease($releaseUuid: ID!) {
                    getVulnAnalysisByRelease(releaseUuid: $releaseUuid) {
                        ${VULN_ANALYSIS_FIELDS_FRAGMENT}
                    }
                }
            `
            analysisVariables = { releaseUuid: selectedRelease.value }
            analysisResponseKey = 'getVulnAnalysisByRelease'
            
            // For release, fetch the release data to get metrics
            useReleaseMetrics = true
        } else if (selectedBranchFeatureSet.value) {
            // Use branch-specific queries
            analysisQuery = gql`
                query getVulnAnalysisByBranch($branchUuid: ID!) {
                    getVulnAnalysisByBranch(branchUuid: $branchUuid) {
                        ${VULN_ANALYSIS_FIELDS_FRAGMENT}
                    }
                }
            `
            analysisVariables = { branchUuid: selectedBranchFeatureSet.value }
            analysisResponseKey = 'getVulnAnalysisByBranch'
            
            findingsQuery = gql`
                query findingsPerDayForBranch($branchUuid: ID!, $date: String!) {
                    findingsPerDayForBranch(branchUuid: $branchUuid, date: $date) {
                        ${FINDINGS_DETAILS_FRAGMENT}
                    }
                }
            `
            findingsVariables = { branchUuid: selectedBranchFeatureSet.value, date: dateStr }
            findingsResponseKey = 'findingsPerDayForBranch'
        } else if (selectedComponentProduct.value) {
            // Use component-specific queries
            analysisQuery = gql`
                query getVulnAnalysisByComponent($componentUuid: ID!) {
                    getVulnAnalysisByComponent(componentUuid: $componentUuid) {
                        ${VULN_ANALYSIS_FIELDS_FRAGMENT}
                    }
                }
            `
            analysisVariables = { componentUuid: selectedComponentProduct.value }
            analysisResponseKey = 'getVulnAnalysisByComponent'
            
            findingsQuery = gql`
                query findingsPerDayForComponent($componentUuid: ID!, $date: String!) {
                    findingsPerDayForComponent(componentUuid: $componentUuid, date: $date) {
                        ${FINDINGS_DETAILS_FRAGMENT}
                    }
                }
            `
            findingsVariables = { componentUuid: selectedComponentProduct.value, date: dateStr }
            findingsResponseKey = 'findingsPerDayForComponent'
        } else {
            // Use perspective or org-level queries
            const usePerspective = myperspective.value && myperspective.value !== 'default'
            
            if (usePerspective) {
                analysisQuery = gql`
                    query getVulnAnalysisByPerspective($perspectiveUuid: ID!) {
                        getVulnAnalysisByPerspective(perspectiveUuid: $perspectiveUuid) {
                            ${VULN_ANALYSIS_FIELDS_FRAGMENT}
                        }
                    }
                `
                analysisVariables = { perspectiveUuid: myperspective.value }
                analysisResponseKey = 'getVulnAnalysisByPerspective'
                
                findingsQuery = gql`
                    query findingsPerDayByPerspective($perspectiveUuid: ID!, $date: String!) {
                        findingsPerDayByPerspective(perspectiveUuid: $perspectiveUuid, date: $date) {
                            ${FINDINGS_DETAILS_FRAGMENT}
                        }
                    }
                `
                findingsVariables = { perspectiveUuid: myperspective.value, date: dateStr }
                findingsResponseKey = 'findingsPerDayByPerspective'
            } else {
                analysisQuery = gql`
                    query getVulnAnalysis($org: ID!) {
                        getVulnAnalysis(org: $org) {
                            ${VULN_ANALYSIS_FIELDS_FRAGMENT}
                        }
                    }
                `
                analysisVariables = { org: myorg.value.uuid }
                analysisResponseKey = 'getVulnAnalysis'
                
                findingsQuery = gql`
                    query findingsPerDay($orgUuid: ID!, $date: String!) {
                        findingsPerDay(orgUuid: $orgUuid, date: $date) {
                            ${FINDINGS_DETAILS_FRAGMENT}
                        }
                    }
                `
                findingsVariables = { orgUuid: myorg.value.uuid, date: dateStr }
                findingsResponseKey = 'findingsPerDay'
            }
        }
        
        // Fetch analysis records
        const analysisResponse = await graphqlClient.query({
            query: analysisQuery,
            variables: analysisVariables,
            fetchPolicy: 'no-cache'
        })
        
        const existingAnalysis = (analysisResponse.data as any)[analysisResponseKey] || []
        
        // Fetch findings (either from release metrics or from findingsPerDay queries)
        let metrics: any = null
        let processedMetrics: any[] = [] // For release data which comes pre-processed
        
        if (useReleaseMetrics) {
            // Fetch release data using ReleaseVulnerabilityService
            const releaseData = await ReleaseVulnerabilityService.fetchReleaseVulnerabilityData(
                selectedRelease.value,
                myorg.value.uuid
            )
            // ReleaseVulnerabilityService returns processed DetailedMetric[] array
            processedMetrics = releaseData.vulnerabilityData || []
            
            // Convert back to raw metrics structure for consistency
            metrics = {
                vulnerabilityDetails: processedMetrics
                    .filter((m: any) => m.type === 'Vulnerability')
                    .map((m: any) => ({
                        purl: m.purl,
                        vulnId: m.id,
                        severity: m.severity,
                        analysisState: m.analysisState,
                        aliases: m.aliases || [],
                        sources: m.sources || []
                    })),
                violationDetails: processedMetrics
                    .filter((m: any) => m.type === 'Violation')
                    .map((m: any) => ({
                        purl: m.purl,
                        type: m.id,
                        license: m.details?.includes('License:') ? m.details.split('License: ')[1] : null,
                        violationDetails: m.details,
                        analysisState: m.analysisState,
                        sources: m.sources || []
                    })),
                weaknessDetails: processedMetrics
                    .filter((m: any) => m.type === 'Weakness')
                    .map((m: any) => ({
                        cweId: m.id,
                        ruleId: m.details,
                        location: m.location,
                        fingerprint: m.fingerprint,
                        severity: m.severity,
                        analysisState: m.analysisState,
                        sources: m.sources || []
                    }))
            }
        } else {
            // Fetch from findingsPerDay queries
            const findingsResponse = await graphqlClient.query({
                query: findingsQuery,
                variables: findingsVariables,
                fetchPolicy: 'no-cache'
            })
            metrics = (findingsResponse.data as any)[findingsResponseKey]
        }
        
        // Determine if any filtering is active
        const hasFiltering = selectedRelease.value || selectedBranchFeatureSet.value || 
                           selectedComponentProduct.value || 
                           (myperspective.value && myperspective.value !== 'default')
        
        // Build a set of finding IDs and location pairs that exist in current scope's metrics
        const scopeFindingIds = new Set<string>()
        const scopeFindingLocations = new Map<string, Set<string>>() // findingId -> Set of locations
        
        if (metrics) {
            // Process vulnerabilities from metrics
            if (metrics.vulnerabilityDetails && Array.isArray(metrics.vulnerabilityDetails)) {
                metrics.vulnerabilityDetails.forEach((vuln: any) => {
                    scopeFindingIds.add(vuln.vulnId)
                    // Add aliases
                    const vulnAliases = vuln.aliases?.map((a: any) => a.aliasId) || []
                    vulnAliases.forEach((alias: string) => scopeFindingIds.add(alias))
                    
                    // Track locations for this finding
                    if (!scopeFindingLocations.has(vuln.vulnId)) {
                        scopeFindingLocations.set(vuln.vulnId, new Set())
                    }
                    scopeFindingLocations.get(vuln.vulnId)!.add(vuln.purl)
                    
                    // Also track locations for aliases
                    vulnAliases.forEach((alias: string) => {
                        if (!scopeFindingLocations.has(alias)) {
                            scopeFindingLocations.set(alias, new Set())
                        }
                        scopeFindingLocations.get(alias)!.add(vuln.purl)
                    })
                })
            }
            
            // Process violations from metrics
            if (metrics.violationDetails && Array.isArray(metrics.violationDetails)) {
                metrics.violationDetails.forEach((violation: any) => {
                    const violationId = `${violation.type}-${violation.license || violation.violationDetails}`
                    scopeFindingIds.add(violationId)
                    
                    if (!scopeFindingLocations.has(violationId)) {
                        scopeFindingLocations.set(violationId, new Set())
                    }
                    scopeFindingLocations.get(violationId)!.add(violation.purl)
                })
            }
            
            // Process weaknesses from metrics
            if (metrics.weaknessDetails && Array.isArray(metrics.weaknessDetails)) {
                metrics.weaknessDetails.forEach((weakness: any) => {
                    // Use CWE ID as the primary identifier, with ruleId as fallback
                    const weaknessId = weakness.cweId || weakness.ruleId
                    if (weaknessId) {
                        scopeFindingIds.add(weaknessId)
                        
                        if (!scopeFindingLocations.has(weaknessId)) {
                            scopeFindingLocations.set(weaknessId, new Set())
                        }
                        scopeFindingLocations.get(weaknessId)!.add(weakness.location)
                    }
                })
            }
        }
        
        // Filter existing analysis records based on whether filtering is active
        let filteredExistingAnalysis = existingAnalysis
        if (hasFiltering) {
            // Only show analysis records that match findings in current scope
            filteredExistingAnalysis = existingAnalysis.filter((record: any) => {
                // Check if the finding ID (or any of its aliases) exists in scope
                const findingIds = [record.findingId, ...(record.findingAliases || [])]
                const hasMatchingId = findingIds.some((id: string) => scopeFindingIds.has(id))
                
                if (!hasMatchingId) return false
                
                // Check if the location matches
                for (const id of findingIds) {
                    const locations = scopeFindingLocations.get(id)
                    if (locations && locations.has(record.location)) {
                        return true
                    }
                }
                
                return false
            })
        }
        
        // Build a set of all analyzed finding IDs and their aliases from filtered analysis
        const analyzedIds = new Set<string>()
        filteredExistingAnalysis.forEach((record: any) => {
            analyzedIds.add(record.findingId)
            if (record.findingAliases && Array.isArray(record.findingAliases)) {
                record.findingAliases.forEach((alias: string) => analyzedIds.add(alias))
            }
        })
        
        // Process findings to create new records for unanalyzed findings
        const newFindings: any[] = []
        
        if (metrics) {
            // Process vulnerabilities
            if (metrics.vulnerabilityDetails && Array.isArray(metrics.vulnerabilityDetails)) {
                metrics.vulnerabilityDetails.forEach((vuln: any) => {
                    // Check if this vulnerability is already analyzed
                    const vulnAliases = vuln.aliases?.map((a: any) => a.aliasId) || []
                    const allIds = [vuln.vulnId, ...vulnAliases]
                    const isAnalyzed = allIds.some((id: string) => analyzedIds.has(id))
                    
                    if (!isAnalyzed) {
                        // Transform to analysis record format
                        newFindings.push({
                            uuid: `new-vuln-${vuln.vulnId}-${vuln.purl}`,
                            org: myorg.value.uuid,
                            location: vuln.purl,
                            locationType: 'PURL',
                            findingId: vuln.vulnId,
                            findingAliases: vulnAliases,
                            findingType: 'VULNERABILITY',
                            scope: 'ORG',
                            scopeUuid: myorg.value.uuid,
                            analysisState: 'IN_TRIAGE',
                            analysisJustification: null,
                            severity: vuln.severity || null,
                            analysisHistory: []
                        })
                    }
                })
            }
            
            // Process violations
            if (metrics.violationDetails && Array.isArray(metrics.violationDetails)) {
                metrics.violationDetails.forEach((violation: any) => {
                    // Create a unique ID for violations (they don't have vulnId)
                    const violationId = `${violation.type}-${violation.license || violation.violationDetails}`
                    
                    if (!analyzedIds.has(violationId)) {
                        newFindings.push({
                            uuid: `new-violation-${violationId}-${violation.purl}`,
                            org: myorg.value.uuid,
                            location: violation.purl,
                            locationType: 'PURL',
                            findingId: violationId,
                            findingAliases: [],
                            findingType: 'VIOLATION',
                            scope: 'ORG',
                            scopeUuid: myorg.value.uuid,
                            analysisState: 'IN_TRIAGE',
                            analysisJustification: null,
                            severity: null,
                            analysisHistory: []
                        })
                    }
                })
            }
            
            // Process weaknesses
            if (metrics.weaknessDetails && Array.isArray(metrics.weaknessDetails)) {
                metrics.weaknessDetails.forEach((weakness: any) => {
                    // Use CWE ID as the primary identifier, with ruleId as fallback
                    const weaknessId = weakness.cweId || weakness.ruleId
                    
                    if (weaknessId && !analyzedIds.has(weaknessId)) {
                        newFindings.push({
                            uuid: `new-weakness-${weaknessId}-${weakness.location}`,
                            org: myorg.value.uuid,
                            location: weakness.location,
                            locationType: 'CODE_POINT',
                            findingId: weaknessId,
                            findingAliases: [],
                            findingType: 'WEAKNESS',
                            scope: 'ORG',
                            scopeUuid: myorg.value.uuid,
                            analysisState: 'IN_TRIAGE',
                            analysisJustification: null,
                            severity: weakness.severity || null,
                            analysisHistory: []
                        })
                    }
                })
            }
        }
        
        // Combine filtered existing analysis and new findings
        analysisRecords.value = [...filteredExistingAnalysis, ...newFindings]
    } catch (error: any) {
        console.error('Error fetching vulnerability analysis records:', error)
        notify('error', 'Error', 'Failed to fetch vulnerability analysis records')
        analysisRecords.value = []
    } finally {
        loading.value = false
    }
}

// Fetch components and products based on perspective
const fetchComponentsProducts = async () => {
    if (!myorg.value || !myorg.value.uuid) return
    
    try {
        // Fetch components and products - store methods automatically handle perspective filtering
        await store.dispatch('fetchComponents', { orgid: myorg.value.uuid, forceRefresh: false })
        await store.dispatch('fetchProducts', { orgid: myorg.value.uuid, forceRefresh: false })
        
        const components = store.getters.componentsOfOrg(myorg.value.uuid) || []
        const products = store.getters.productsOfOrg(myorg.value.uuid) || []
        componentsProducts.value = [...components, ...products]
    } catch (error: any) {
        console.error('Error fetching components/products:', error)
        componentsProducts.value = []
    }
}

// Fetch branches for selected component/product
const fetchBranches = async () => {
    if (!selectedComponentProduct.value) {
        branches.value = []
        return
    }
    
    try {
        await store.dispatch('fetchBranches', selectedComponentProduct.value)
        branches.value = store.getters.branchesOfComponent(selectedComponentProduct.value) || []
    } catch (error: any) {
        console.error('Error fetching branches:', error)
        branches.value = []
    }
}

// Fetch releases for selected branch
const fetchReleases = async () => {
    if (!selectedBranchFeatureSet.value) {
        releases.value = []
        return
    }
    
    try {
        // Check if releases are already in store
        let storeReleases = store.getters.releasesOfBranch(selectedBranchFeatureSet.value)
        if (!storeReleases || !storeReleases.length) {
            // Fetch releases from server
            await store.dispatch('fetchReleases', { branch: selectedBranchFeatureSet.value })
            storeReleases = store.getters.releasesOfBranch(selectedBranchFeatureSet.value)
        }
        // Sort by createdDate descending (newest first)
        releases.value = (storeReleases || []).sort((a: any, b: any) => {
            return new Date(b.createdDate).getTime() - new Date(a.createdDate).getTime()
        })
    } catch (error: any) {
        console.error('Error fetching releases:', error)
        releases.value = []
    }
}

// Clear downstream selectors when upstream changes
const clearDownstreamSelectors = (level: 'type' | 'component' | 'branch') => {
    if (level === 'type') {
        selectedComponentProduct.value = ''
        selectedBranchFeatureSet.value = ''
        selectedRelease.value = ''
        branches.value = []
        releases.value = []
    } else if (level === 'component') {
        selectedBranchFeatureSet.value = ''
        selectedRelease.value = ''
        releases.value = []
    } else if (level === 'branch') {
        selectedRelease.value = ''
    }
}

onMounted(async () => {
    await fetchComponentsProducts()
    if (selectedComponentProduct.value) {
        await fetchBranches()
        if (selectedBranchFeatureSet.value) {
            await fetchReleases()
        }
    }
    fetchAnalysisRecords()
    
    // Handle cveId query parameter to open modal
    if (route.query.cveId && typeof route.query.cveId === 'string') {
        selectedCveId.value = route.query.cveId
        showViewReleasesModal.value = true
    }
})

// Watch perspective changes - reset all filters to 'ANY' and refetch
watch(myperspective, async () => {
    // Reset all filter selectors to their default state
    selectedType.value = 'COMPONENT'
    selectedComponentProduct.value = ''
    selectedBranchFeatureSet.value = ''
    selectedRelease.value = ''
    
    // Clear data arrays
    componentsProducts.value = []
    branches.value = []
    releases.value = []
    
    // Update URL to reflect cleared filters
    router.push({ query: { ...route.query, type: 'COMPONENT', componentProduct: undefined, branchFeatureSet: undefined, release: undefined } })
    
    // Fetch new component/product list for the new perspective
    await fetchComponentsProducts()
    
    // Refetch analysis records
    fetchAnalysisRecords()
})

// Watch type changes
watch(selectedType, () => {
    clearDownstreamSelectors('type')
    router.push({ query: { ...route.query, type: selectedType.value, componentProduct: '', branchFeatureSet: '', release: '' } })
})

// Watch component/product changes
watch(selectedComponentProduct, async (newVal) => {
    clearDownstreamSelectors('component')
    if (newVal) {
        await fetchBranches()
    }
    const query = { ...route.query, componentProduct: newVal || undefined, branchFeatureSet: '', release: '' }
    if (!newVal) delete query.componentProduct
    router.push({ query })
})

// Watch branch/feature set changes
watch(selectedBranchFeatureSet, async (newVal) => {
    clearDownstreamSelectors('branch')
    if (newVal) {
        await fetchReleases()
    }
    const query = { ...route.query, branchFeatureSet: newVal || undefined, release: '' }
    if (!newVal) delete query.branchFeatureSet
    router.push({ query })
})

// Watch release changes
watch(selectedRelease, (newVal) => {
    const query = { ...route.query, release: newVal || undefined }
    if (!newVal) delete query.release
    router.push({ query })
})

// Watch any filter change to refetch analysis records
watch([selectedType, selectedComponentProduct, selectedBranchFeatureSet, selectedRelease], () => {
    fetchAnalysisRecords()
})
</script>

<style scoped>
h4 {
    margin-bottom: 20px;
}
</style>
